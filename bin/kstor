#!/usr/bin/env ruby
# frozen_string_literal: true

require 'kstor'

require 'json'
require 'socket'
require 'etc'
require 'fileutils'
require 'slop'

module KStor
  # Manage KStor client configuration and state on disk.
  module ClientState
    class << self
      # Default client config.
      DEFAULT_CONFIG = {
        'socket' => '/run/kstor.socket'
      }.freeze

      # Load client config from disk.
      def load_config(progr)
        DEFAULT_CONFIG.merge(load_config_file(progr))
      end

      # Path to session ID file on disk.
      def session_id_file(progr)
        dir = File.join(xdg_runtime, progr)
        FileUtils.mkdir_p(dir)
        file = File.join(dir, 'session-id')
        FileUtils.touch(file)
        FileUtils.chmod(0o600, file)
        file
      end

      # Load session ID from disk.
      def load_session_id(progr)
        sid = nil
        File.open(session_id_file(progr)) { |f| sid = f.read.chomp }
        sid = nil if sid.empty?

        sid
      end

      private

      def xdg_config
        ENV.fetch('XDG_CONFIG_HOME', File.join(Dir.home, '.config'))
      end

      def xdg_state
        ENV.fetch('XDG_STATE_HOME', File.join(Dir.home, '.local', 'state'))
      end

      def xdg_runtime
        dir = ENV.fetch('XDG_RUNTIME_DIR', nil)
        return dir if dir

        warn('XDG_RUNTIME_DIR is undefined, using XDG_STATE_HOME instead')
        xdg_state
      end

      def config_file(progr)
        dir = File.join(xdg_config, progr)
        FileUtils.mkdir_p(dir)
        File.join(dir, 'config.yaml')
      end

      def load_config_file(progr)
        YAML.load_file(config_file(progr))
      rescue Errno::ENOENT
        {}
      end
    end
  end

  # Sub-commands that can be invoked from the command-line.
  module ClientSubCommands
    # Create a user group.
    def group_create
      request('group_create') do |o|
        o.string('-n', '--name', 'Group name')
      end
    end

    # Rename a group.
    def group_rename
      request('group_rename') do |o|
        o.integer('-g', '--group-id', 'ID of group to rename')
        o.string('-n', '--name', 'New name of group')
      end
    end

    # Delete a group
    def group_delete
      request('group_delete') do |o|
        o.integer('-g', '--group-id', 'ID of group to delete')
      end
    end

    # Search groups by name.
    def group_search
      request('group_search') do |o|
        o.string('-n', '--name', 'Name or wildcard to search')
      end
    end

    # Get info on a group
    def group_get
      request('group_get') do |o|
        o.integer('-g', '--group-id', 'ID of group to show')
      end
    end

    # Create user
    def user_create
      request('user_create') do |o|
        o.string('-l', '--user-login', 'Login of new user')
        o.string('-n', '--user-name', 'Name of new user')
        o.integer(
          '-t', '--token-lifespan', 'Validity of token in seconds',
          default: 60 * 60
        )
      end
    end

    # Activate new user.
    def user_activate
      request('user_activate') do |o|
        o.string('-t', '--token', 'activation token')
      end
    end

    # Create a secret.
    def secret_create
      request_with_meta('secret_create') do |o|
        o.string('-p', '--plaintext', 'Value of the secret')
        o.array('-g', '--group_ids', 'Groups that can unlock the secret')
        o.string('-a', '--app', 'application of this secret')
        o.string('-d', '--database', 'database of this secret')
        o.string('-l', '--login', 'login of this secret')
        o.string('-S', '--server', 'server of this secret')
        o.string('-u', '--url', 'url for this secret')
      end
    end

    # Return a list of matching secrets.
    def secret_search
      request_with_meta('secret_search') do |o|
        o.string('-a', '--app', 'secrets for this application')
        o.string('-d', '--database', 'secrets for this database')
        o.string('-l', '--login', 'secrets for this login')
        o.string('-s', '--server', 'secrets for this server')
        o.string('-u', '--url', 'secrets for this url')
      end
    end

    # Decrypt secret value and metadata
    def secret_unlock
      request('secret_unlock') do |o|
        o.string('-s', '--secret-id', 'secret ID to unlock')
      end
    end

    # Update secret metadata
    def secret_update_meta
      request_with_meta('secret_update_meta') do |o|
        o.string('-s', '--secret-id', 'secret ID to modify')
        o.string('-a', '--app', 'new application of this secret')
        o.string('-d', '--database', 'new database of this secret')
        o.string('-l', '--login', 'new login of this secret')
        o.string('-S', '--server', 'new server of this secret')
        o.string('-u', '--url', 'new url for this secret')
      end
    end

    # Update secret value
    def secret_update_value
      request('secret_update_value') do |o|
        o.string('-s', '--secret-id', 'secret ID to modify')
        o.string('-p', '--plaintext', 'new plaintext value')
      end
    end

    # Delete secret
    def secret_delete
      request('secret_delete') do |o|
        o.string('-s', '--secret-id', 'secret ID to delete')
      end
    end
  end

  # KStor command-line client.
  class Client
    include ClientSubCommands

    # Create new command-line client.
    def initialize
      @progr = File.basename($PROGRAM_NAME)
      @config = ClientState.load_config(@progr)
      @user = user_from_argv
    end

    # Read command-line args, send request to server and display results..
    def run
      request_type = ARGV.shift.to_sym
      resp = send_request(request_type)
      handle_error!(resp) if resp.error?

      puts format_response(resp)
      return unless resp.respond_to?(:session_id)

      File.open(ClientState.session_id_file(@progr), 'w') do |f|
        f.puts(resp.session_id)
      end
    end

    private

    def format_response(resp)
      data = resp.args.dup
      data.delete('session_id')
      JSON.pretty_generate(data)
    end

    def reorganize_secret_meta_args(req)
      req.args['meta'] = {
        'app' => req.args.delete('app'),
        'database' => req.args.delete('database'),
        'login' => req.args.delete('login'),
        'server' => req.args.delete('server'),
        'url' => req.args.delete('url')
      }
      req.args['meta'].compact!
      req
    end

    def handle_error!(resp)
      if resp.code == 'AUTH/BADSESSION'
        FileUtils.rm(ClientState.session_id_file(@progr))
        warn('session expired')
      else
        warn(resp.args['message'])
      end
      exit 1
    end

    def send_request(request_type)
      meth = method_name(request_type)

      req = __send__(meth)
      socket = UNIXSocket.new(@config['socket'])
      socket.send(req.serialize, 0)

      data, = socket.recvfrom(4096)
      Message::Base.parse(data)
    rescue Message::UnparsableResponse
      warn('Invalid response from server; look at logs!')
      exit(1)
    end

    def method_name(request_type)
      if request_type.nil?
        base_usage
        exit 0
      end
      unless KStor::Message::Base.type?(request_type)
        warn("Unknown request type #{request_type.inspect}")
        base_usage
        exit 1
      end
      request_type
    end

    def user_from_argv
      md = /^(-u|--user)$/.match(ARGV.first)
      md ? ARGV.shift(2).last : Etc.getlogin
    end

    def base_usage
      puts "usage: #{@progr} [--user USER] <req-type> [--help | REQ-ARGS]"
      request_types = %w[group-create secret-create secret-search secret-unlock]
      puts "request types: #{request_types.join(', ')}"
    end

    def ask_password
      require 'io/console'

      $stdout.print 'Password: '
      password = $stdin.noecho(&:gets)
      $stdout.puts('')

      password.chomp
    end

    def auth
      session_id = ClientState.load_session_id(@progr)

      if session_id
        { session_id: }
      else
        { login: @user, password: ask_password }
      end
    end

    def request_with_meta(type, &block)
      args = parse_opts(type) { |o| block.call(o) }
      args['meta'] = {
        'app' => args.delete('app'),
        'database' => args.delete('database'),
        'login' => args.delete('login'),
        'server' => args.delete('server'),
        'url' => args.delete('url')
      }
      args['meta'].compact!
      KStor::Message::Base.for_type(type, args, auth)
    end

    def request(type, &block)
      args = parse_opts(type) { |o| block.call(o) }
      KStor::Message::Base.for_type(type, args, auth)
    end

    def parse_opts(request_type)
      opts = Slop.parse do |o|
        o.banner = <<-EOUSAGE
        usage: #{@progr} [--user USER] #{request_type} [--help | REQ-ARGS]
        EOUSAGE
        o.on('-h', '--help', 'show this text') do
          puts o
          exit 0
        end
        o.separator('')
        yield o
      end
      opts.to_hash.compact.transform_keys(&:to_s)
    end
  end
end

cli = KStor::Client.new
cli.run
