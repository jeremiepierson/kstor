#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'kstor/message'

require 'json'
require 'socket'
require 'etc'
require 'fileutils'
require 'slop'

def base_usage
  me = File.basename($PROGRAM_NAME)
  puts "usage: #{me} [--user USER] <request-type> [--help | REQUEST-ARGS]"
  request_types = %w[group-create secret-create secret-search secret-unlock]
  puts "request types: #{request_types.join(', ')}"
end

def parse_opts(request_type, progr)
  opts = Slop.parse do |o|
    o.banner = "usage: #{progr} [auth-opts] #{request_type} [request-args]"
    o.on('-h', '--help', 'show this text') do
      puts o
      exit 0
    end
    o.separator('')
    yield o
  end
  opts.to_hash.compact
end

def ask_password
  require 'io/console'

  $stdout.print 'Password: '
  password = $stdin.noecho(&:gets)
  $stdout.puts('')

  password.chomp
end

def xdg_config
  ENV.fetch('XDG_CONFIG_HOME', File.join(Dir.home, '.config'))
end

def xdg_state
  ENV.fetch('XDG_STATE_HOME', File.join(Dir.home, '.local', 'state'))
end

def xdg_runtime
  dir = ENV.fetch('XDG_RUNTIME_DIR', nil)
  return dir if dir

  warn('XDG_RUNTIME_DIR is undefined, using XDG_STATE_HOME instead')
  xdg_state
end

def session_id_file(progr)
  dir = File.join(xdg_runtime, progr)
  FileUtils.mkdir_p(dir)
  file = File.join(dir, 'session-id')
  FileUtils.touch(file)
  FileUtils.chmod(0o600, file)
  file
end

def config_file(progr)
  dir = File.join(xdg_config, progr)
  FileUtils.mkdir_p(dir)
  File.join(dir, 'session-id')
end

def load_config_file(progr)
  data = File.read(config_file(progr))
  YAML.parse(data)
rescue Errno::ENOENT
  {}
end

DEFAULT_CONFIG = {
  'socket' => '/home/jpi/code/kstor/testworkdir/kstor.socket'
}.freeze

def config(progr)
  DEFAULT_CONFIG.merge(load_config_file(progr))
end

def load_session_id(progr)
  sid = nil
  File.open(session_id_file(progr)) { |f| sid = f.read.chomp }
  sid = nil if sid.empty?

  sid
end

def get_auth(user, progr)
  session_id = load_session_id(progr)

  if session_id
    { 'session_id' => session_id }
  else
    { 'login' => user, 'password' => ask_password }
  end
end

def request(progr, user, type, &block)
  hreq = {}
  hreq['type'] = type.tr('-', '_')
  hreq['args'] = parse_opts(type, progr) do |o|
    block.call(o)
  end
  KStor::Message.parse_request(hreq.merge(get_auth(user, progr)).to_json)
end

def group_create(progr, user)
  request(progr, user, 'group-create') do |o|
    o.string('-n', '--name', 'Group name')
  end
end

def reorganize_secret_meta_args(req)
  req.args['meta'] = {
    'app' => req.args.delete('app'),
    'database' => req.args.delete('database'),
    'login' => req.args.delete('login'),
    'server' => req.args.delete('server'),
    'url' => req.args.delete('url')
  }
  req.args['meta'].compact!
  req
end

def secret_create(progr, user)
  req = request(progr, user, 'secret-create') do |o|
    o.string('-p', '--plaintext', 'Value of the secret')
    o.array('-g', '--group_ids', 'Groups that can unlock the secret')
    o.string('-a', '--app', 'application of this secret')
    o.string('-d', '--database', 'database of this secret')
    o.string('-l', '--login', 'login of yhis secret')
    o.string('-s', '--server', 'server of this secret')
    o.string('-u', '--url', 'url for this secret')
  end
  reorganize_secret_meta_args(req)
end

def secret_search(progr, user)
  request(progr, user, 'secret-search') do |o|
    o.string('-a', '--app', 'secrets for this application')
    o.string('-d', '--database', 'secrets for this database')
    o.string('-l', '--login', 'secrets for this login')
    o.string('-s', '--server', 'secrets for this server')
    o.string('-u', '--url', 'secrets for this url')
  end
end

def secret_unlock(progr, user)
  request(progr, user, 'secret-unlock') do |o|
    o.string('-s', '--secret-id', 'secret ID to unlock')
  end
end

def method_name(request_type)
  case request_type
  when 'group-create' then :group_create
  when 'secret-create' then :secret_create
  when 'secret-search' then :secret_search
  when 'secret-unlock' then :secret_unlock
  when nil, '--help', '-h'
    base_usage
    exit 0
  else
    warn("Unknown request type #{request_type.inspect}")
    base_usage
    exit 1
  end
end

progr = File.basename($PROGRAM_NAME)
cfg = config(progr)

md = /^(-u|--user)$/.match(ARGV.first)
if md
  ARGV.shift
  user = ARGV.shift
else
  user = Etc.getlogin
end
request_type = ARGV.shift

meth = method_name(request_type)

req = __send__(meth, progr, user)
socket = UNIXSocket.new(cfg['socket'])
puts req.serialize
socket.send(req.serialize, 0)

data, = socket.recvfrom(4096)
resp = KStor::Response.parse(data)

if resp.error?
  if resp.args['code'] == 'AUTH/BADSESSION'
    FileUtils.rm(session_id_file(progr))
    warn('session expired')
  else
    warn(resp.args['message'])
  end
  exit 1
else
  puts resp.serialize

  if resp.respond_to?(:session_id)
    File.open(session_id_file(progr), 'w') { |f| f.puts(resp.session_id) }
  end
end
