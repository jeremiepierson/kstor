#!/usr/bin/env ruby
# frozen_string_literal: true

require 'kstor'

require 'json'
require 'socket'
require 'etc'
require 'fileutils'
require 'slop'

module KStor
  # Manage KStor client configuration and state on disk.
  module ClientState
    class << self
      DEFAULT_CONFIG = {
        'socket' => '/home/jpi/code/kstor/testworkdir/kstor.socket'
      }.freeze

      def load_config(progr)
        DEFAULT_CONFIG.merge(load_config_file(progr))
      end

      def session_id_file(progr)
        dir = File.join(xdg_runtime, progr)
        FileUtils.mkdir_p(dir)
        file = File.join(dir, 'session-id')
        FileUtils.touch(file)
        FileUtils.chmod(0o600, file)
        file
      end

      def load_session_id(progr)
        sid = nil
        File.open(session_id_file(progr)) { |f| sid = f.read.chomp }
        sid = nil if sid.empty?

        sid
      end

      private

      def xdg_config
        ENV.fetch('XDG_CONFIG_HOME', File.join(Dir.home, '.config'))
      end

      def xdg_state
        ENV.fetch('XDG_STATE_HOME', File.join(Dir.home, '.local', 'state'))
      end

      def xdg_runtime
        dir = ENV.fetch('XDG_RUNTIME_DIR', nil)
        return dir if dir

        warn('XDG_RUNTIME_DIR is undefined, using XDG_STATE_HOME instead')
        xdg_state
      end

      def config_file(progr)
        dir = File.join(xdg_config, progr)
        FileUtils.mkdir_p(dir)
        File.join(dir, 'session-id')
      end

      def load_config_file(progr)
        data = File.read(config_file(progr))
        YAML.parse(data)
      rescue Errno::ENOENT
        {}
      end
    end
  end

  # Sub-commands that can be invoked from the command-line.
  module ClientSubCommands
    def group_create
      request('group-create') do |o|
        o.string('-n', '--name', 'Group name')
      end
    end

    def secret_create
      req = request('secret-create') do |o|
        o.string('-p', '--plaintext', 'Value of the secret')
        o.array('-g', '--group_ids', 'Groups that can unlock the secret')
        o.string('-a', '--app', 'application of this secret')
        o.string('-d', '--database', 'database of this secret')
        o.string('-l', '--login', 'login of this secret')
        o.string('-S', '--server', 'server of this secret')
        o.string('-u', '--url', 'url for this secret')
      end
      reorganize_secret_meta_args(req)
    end

    def secret_search
      request('secret-search') do |o|
        o.string('-a', '--app', 'secrets for this application')
        o.string('-d', '--database', 'secrets for this database')
        o.string('-l', '--login', 'secrets for this login')
        o.string('-s', '--server', 'secrets for this server')
        o.string('-u', '--url', 'secrets for this url')
      end
    end

    def secret_unlock
      request('secret-unlock') do |o|
        o.string('-s', '--secret-id', 'secret ID to unlock')
      end
    end

    def secret_update_meta
      req = request('secret-update-meta') do |o|
        o.string('-s', '--secret-id', 'secret ID to modify')
        o.string('-a', '--app', 'new application of this secret')
        o.string('-d', '--database', 'new database of this secret')
        o.string('-l', '--login', 'new login of this secret')
        o.string('-S', '--server', 'new server of this secret')
        o.string('-u', '--url', 'new url for this secret')
      end
      reorganize_secret_meta_args(req)
    end

    def secret_update_value
      request('secret-update-value') do |o|
        o.string('-s', '--secret-id', 'secret ID to modify')
        o.string('-p', '--plaintext', 'new plaintext value')
      end
    end

    def secret_delete
      request('secret-delete') do |o|
        o.string('-s', '--secret-id', 'secret ID to delete')
      end
    end
  end

  # KStor command-line client.
  class Client
    include ClientSubCommands

    def initialize
      @progr = File.basename($PROGRAM_NAME)
      @config = ClientState.load_config(@progr)
      @user = user_from_argv
    end

    def run
      request_type = ARGV.shift
      resp = send_request(request_type)
      handle_error!(resp) if resp.error?

      puts format_response(resp)
      return unless resp.respond_to?(:session_id)

      File.open(ClientState.session_id_file(@progr), 'w') do |f|
        f.puts(resp.session_id)
      end
    end

    private

    def format_response(resp)
      data = resp.args.dup
      data.delete('session_id')
      JSON.pretty_generate(data)
    end

    def reorganize_secret_meta_args(req)
      req.args['meta'] = {
        'app' => req.args.delete('app'),
        'database' => req.args.delete('database'),
        'login' => req.args.delete('login'),
        'server' => req.args.delete('server'),
        'url' => req.args.delete('url')
      }
      req.args['meta'].compact!
      req
    end

    def handle_error!(resp)
      if resp.args['code'] == 'AUTH/BADSESSION'
        FileUtils.rm(ClientState.session_id_file(@progr))
        warn('session expired')
      else
        warn(resp.args['message'])
      end
      exit 1
    end

    def send_request(request_type)
      meth = method_name(request_type)

      req = __send__(meth)
      socket = UNIXSocket.new(@config['socket'])
      socket.send(req.serialize, 0)

      data, = socket.recvfrom(4096)
      Response.parse(data)
    rescue UnparsableResponse
      warn('server speaks funny; look at logs!')
      exit(1)
    end

    REQUEST_METHODS = {
      'group-create' => :group_create,
      'secret-create' => :secret_create,
      'secret-search' => :secret_search,
      'secret-unlock' => :secret_unlock,
      'secret-update-meta' => :secret_update_meta,
      'secret-update-value' => :secret_update_value,
      'secret-delete' => :secret_delete
    }.freeze

    def method_name(request_type)
      if request_type.nil?
        base_usage
        exit 0
      end
      meth = REQUEST_METHODS[request_type]
      if meth.nil?
        warn("Unknown request type #{request_type.inspect}")
        base_usage
        exit 1
      end
      meth
    end

    def user_from_argv
      md = /^(-u|--user)$/.match(ARGV.first)
      md ? ARGV.shift(2).last : Etc.getlogin
    end

    def base_usage
      puts "usage: #{@progr} [--user USER] <req-type> [--help | REQ-ARGS]"
      request_types = %w[group-create secret-create secret-search secret-unlock]
      puts "request types: #{request_types.join(', ')}"
    end

    def ask_password
      require 'io/console'

      $stdout.print 'Password: '
      password = $stdin.noecho(&:gets)
      $stdout.puts('')

      password.chomp
    end

    def auth
      session_id = ClientState.load_session_id(@progr)

      if session_id
        { 'session_id' => session_id }
      else
        { 'login' => @user, 'password' => ask_password }
      end
    end

    def request(type, &block)
      hreq = {}
      hreq['type'] = type
      hreq['args'] = parse_opts(type) do |o|
        block.call(o)
      end
      KStor::Message.parse_request(hreq.merge(auth).to_json)
    end

    def parse_opts(request_type)
      opts = Slop.parse do |o|
        o.banner = <<-EOUSAGE
        usage: #{@progr} [--user USER] #{request_type} [--help | REQ-ARGS]
        EOUSAGE
        o.on('-h', '--help', 'show this text') do
          puts o
          exit 0
        end
        o.separator('')
        yield o
      end
      opts.to_hash.compact
    end
  end
end

cli = KStor::Client.new
cli.run
